module Account where 

import qualified DA.Set as Set
import DA.Foldable (forA_)
import qualified DA.List as L
import DA.Action (when)
import DA.Optional (whenSome)
import Asset

-- validate input and return difference between asset amounts and split amounts
validateMergeSplitInput: AssetHoldingAccount -> [ContractId Asset] -> [Decimal] -> Update Decimal 
validateMergeSplitInput account assetCids amounts = do 
  forA_ amounts \amount -> assertMsg "amount must > 0" (amount > 0.0)
  let splitAmount = sum amounts 
  totalAssetAmount <- sum <$> forA assetCids \assetCid -> do 
    asset <- fetch assetCid 
    assertMsg "asset type mismatch between account and asset" (asset.assetType == account.assetType)
    assertMsg "cannot merge split asset of another owner" (asset.owner == account.owner)
    return asset.amount 
  assertMsg "asset amounts must be greater than split amounts" (totalAssetAmount >= splitAmount)

  return (totalAssetAmount - splitAmount)

-- AssetHoldingAccount needs invitation from issuer
-- owner can propose close account, issuer accepts with list of assetCids because needs to call from client side
-- Invite_New_Asset_Holder, Airdrop, Merge_Split
-- Create_Transfers && Deposit_Transfer_Into_Account

template AssetHoldingAccount with 
    assetType: AssetType 
    owner: Party 
    airdroppable: Bool 
    resharable: Bool 
  where 
    signatory assetType.issuer, owner 
    key (assetType, owner): (AssetType, Party) 
    maintainer key._1.issuer 

    nonconsuming choice Invite_New_Asset_Holder: ContractId AssetHoldingAccountProposal with 
        recipient: Party 
      controller (if resharable then owner else assetType.issuer)  
      do 
        create AssetHoldingAccountProposal with assetHoldingAccount = this , recipient 

    -- assetCids obtained in client side and passed to choice arguments
    nonconsuming choice Merge_Split: [ContractId Asset] with 
        assetCids: [ContractId Asset] 
        amounts: [Decimal] 
      controller owner 
      do 
        assertMsg "can only merge split fungible" (assetType.fungible)
        difference <- validateMergeSplitInput this assetCids amounts 
        forA_ assetCids archive 
        newAssetCids <- forA amounts \amount -> do 
          create Asset with assetType, owner, amount, observers = Set.empty 
        if (difference > 0.0) then do 
          otherAssetCid <- (create Asset with assetType, owner, amount = difference, observers = Set.empty)
          return (otherAssetCid :: newAssetCids)
        else return newAssetCids 
    
    nonconsuming choice Merge_Split_With_Nonfungible: [ContractId Asset] with 
        assetCids: [ContractId Asset] 
        amounts: [Decimal] 
      controller owner 
      do 
        assertMsg "can only merge split fungible" (assetType.fungible)
        difference <- validateMergeSplitInput this assetCids amounts 
        forA_ assetCids archive 
        newAssetCids <- forA amounts \amount -> do 
          create Asset with assetType, owner, amount, observers = Set.empty 
        if (difference > 0.0) then do 
          otherAssetCid <- (create Asset with assetType, owner, amount = difference, observers = Set.empty)
          return (otherAssetCid :: newAssetCids)
        else return newAssetCids 
    
    nonconsuming choice Airdrop : ContractId Asset
      with
        amount : Decimal
      controller assetType.issuer 
      do
        assertMsg "account not airdroppable or issuer airdropping self" (airdroppable || assetType.issuer == owner)
        assertMsg "nonfungible must have amount equals 1.0" $ (assetType.fungible || amount==1.0)
        create Asset with assetType, owner, amount, observers = Set.empty
    
    nonconsuming choice Create_Transfers: [ContractId AssetTransfer]
      with 
        assetCids: [ContractId Asset] 
        transfers: [(Decimal, Party)]
      controller owner 
      do 
        let (amounts, newOwners) = unzip transfers 
        assertMsg "can only transfer 1 nonfungile asset at a time" (assetType.fungible || (length assetCids == 1 && length transfers == 1 && L.head amounts == 1.0))
        difference <- validateMergeSplitInput this assetCids amounts 
        forA_ assetCids archive
        newAssetCids <- forA transfers \(amount, newOwner) -> do 
          create AssetTransfer with 
            asset = Asset with 
              assetType 
              owner
              amount 
              observers = Set.empty 
            receiver = newOwner 
        when (difference > 0.0) do 
          create Asset with assetType, owner, amount = difference, observers = Set.empty
          return ()
        return newAssetCids 
    
    nonconsuming choice Deposit_Transfer_Into_Account: ContractId Asset 
      with 
        assetTransferCid: ContractId AssetTransfer 
      controller owner 
      do 
        assetTransfer <- fetch assetTransferCid 
        assertMsg "not same assetType" (assetTransfer.asset.assetType == assetType)
        assertMsg "asset holding owner and asset transfer receiver mismatch" (assetTransfer.receiver == owner)
        create Asset with assetType, owner, amount = assetTransfer.asset.amount, observers = Set.empty 
    
    nonconsuming choice Deposit_Multiple_Transfers: [ContractId Asset]
      with 
        assetTransferCids: [ContractId AssetTransfer] 
      controller owner 
      do 
        forA assetTransferCids $ \assetTransferCid -> do 
          assetTransfer <- fetch assetTransferCid 
          assertMsg "not same assetType" (assetTransfer.asset.assetType == assetType)
          assertMsg "asset holding owner and asset transfer receiver mismatch" (assetTransfer.receiver == owner)
          create Asset with assetType, owner, amount = assetTransfer.asset.amount, observers = Set.empty 
    
    nonconsuming choice Create_Trade: ContractId Trade 
      with 
        assetCids: [ContractId Asset] 
        offeredAmount: Decimal 
        requestedAsset: Asset 
      controller owner 
      do 
        assertMsg "can only trade 1 nonfungile asset at a time" (assetType.fungible || (length assetCids == 1 && offeredAmount == 1.0))
        assertMsg "can only trade for 1 nonfungible asset at a time" (requestedAsset.assetType.fungible || requestedAsset.amount == 1.0)
        difference <- validateMergeSplitInput this assetCids [offeredAmount] 
        forA_ assetCids archive 
        
        assetInSwapCid <- create AssetInSwap with 
          asset = Asset with assetType, owner, amount = offeredAmount, observers = Set.empty 
          newOwner = requestedAsset.owner 
        when (difference > 0.0) do 
          create Asset with assetType, owner, amount = difference, observers = Set.empty 
          return () 
        -- sending asset and requested asset might be of different asset type
        (senderReceivingAssetAccountCid, _) <- fetchByKey @AssetHoldingAccount (requestedAsset.assetType, owner)
        requestedAssetPreApprovalCid <- exercise senderReceivingAssetAccountCid Preapprove_Transfer with 
          asset = requestedAsset 
        create Trade with 
          proposer = owner 
          receiver = requestedAsset.owner 
          baseAssetInSwapCid = assetInSwapCid 
          requestedAssetPreApprovalCid 

    nonconsuming choice Preapprove_Transfer: ContractId TransferPreApproval 
      with 
        asset: Asset 
      controller owner 
      do 
        create TransferPreApproval with 
          asset 
          newOwner = owner 
    
    nonconsuming choice Close_Account: ContractId AssetHoldingAccountCloseProposal 
      controller owner 
      do 
        create AssetHoldingAccountCloseProposal with account = this 

template AssetHoldingAccountProposal with 
    assetHoldingAccount: AssetHoldingAccount -- Record data type 
    recipient: Party -- we can remove this and use assetHoldingAccount.owner but it would make code hard to read
  where 
    signatory assetHoldingAccount.assetType.issuer 
    observer recipient 
    
    choice AssetHoldingAccountProposal_Accept: ContractId AssetHoldingAccount 
      controller recipient 
      do 
        create assetHoldingAccount with owner = recipient 
    
    choice AssetHoldingAccountProposal_Reject: () 
      controller recipient 
      do
        return ()
    
    choice AssetHoldingAccountProposal_Cancel: () 
      controller assetHoldingAccount.assetType.issuer 
      do 
        return () 

-- use AssetInSwap to lock the Asset 
-- cancel_swap first then cancel_trade => fail => AssetInSwap needs to have 2 signatories
template AssetInSwap with 
    asset: Asset 
    newOwner: Party 
  where 
    signatory (signatory asset) 
    observer newOwner 

    choice Cancel_Swap: ContractId Asset 
      controller asset.owner 
      do 
        create asset 
    
    choice Reject_Swap: ContractId Asset 
      controller newOwner 
      do 
        create asset 

-- preapproval created by receiver, asset is of sender
template TransferPreApproval with 
    asset: Asset 
    newOwner: Party 
  where 
    signatory asset.assetType.issuer, newOwner 
    observer asset.owner 

    choice TransferPreApproval_Reject: () 
      controller newOwner 
      do 
        return () 
    
    choice TransferPreApproval_Cancel: () 
      controller asset.owner 
      do 
        return ()
    
    choice TransferPreApproval_Accept: ContractId Asset 
      with 
        assetCid: ContractId Asset 
      controller asset.owner, newOwner 
      do 
        fetchedAsset <- fetch assetCid 
        assertMsg "preapproval asset and provided asset are not the same" (asset == fetchedAsset with observers = asset.observers)
        archive assetCid 
        create asset with owner = newOwner, observers = Set.empty 
    choice TransferPreApproval_AcceptSwap: ContractId Asset 
      with 
        assetInSwapCid: ContractId AssetInSwap 
      controller asset.owner, newOwner 
      do 
        assetInSwap <- fetch assetInSwapCid 
        assertMsg "preapproval asset and provided asset in swap are not the same" (asset == assetInSwap.asset with observers = asset.observers)
        archive assetInSwapCid
        create asset with owner = newOwner, observers = Set.empty 

template Trade with 
    proposer: Party 
    receiver: Party 
    baseAssetInSwapCid: ContractId AssetInSwap 
    requestedAssetPreApprovalCid: ContractId TransferPreApproval
  where 
    signatory proposer 
    observer receiver 

    choice Trade_Accept: (ContractId Asset, ContractId Asset) 
      with 
        requestedAssetCids: [ContractId Asset] 
      controller receiver  
      do 
        baseAssetInSwap <- fetch baseAssetInSwapCid
        -- need to account for receiver having 2 AssetHoldingAccounts, 1 for receiving asset of one type and 1 for sending asset of another type
        (receiverReceivingAssetAccountCid, _) <- fetchByKey @AssetHoldingAccount (baseAssetInSwap.asset.assetType, receiver)
        requestedAssetPreApproval <- fetch requestedAssetPreApprovalCid
        (receiverSendingAssetAccountCid, receiverSendingAssetAccount) <- fetchByKey @AssetHoldingAccount (requestedAssetPreApproval.asset.assetType, receiver) 
        assertMsg "receiver can only offer 1 nonfungible asset" (receiverSendingAssetAccount.assetType.fungible || length requestedAssetCids == 1)
        requestedAssetMergeSplitCids <- 
          if (receiverSendingAssetAccount.assetType.fungible) then 
            exercise receiverSendingAssetAccountCid Merge_Split with 
              assetCids = requestedAssetCids 
              amounts = [requestedAssetPreApproval.asset.amount]
          else 
            return requestedAssetCids
        baseAssetPreApprovalCid <- exercise receiverReceivingAssetAccountCid Preapprove_Transfer with 
          asset = baseAssetInSwap.asset 
        newReceiverAsset <- exercise baseAssetPreApprovalCid TransferPreApproval_AcceptSwap with assetInSwapCid = baseAssetInSwapCid
        newProposerAsset <- exercise requestedAssetPreApprovalCid TransferPreApproval_Accept with assetCid = L.last requestedAssetMergeSplitCids
        return (newProposerAsset, newReceiverAsset)
    
    choice Trade_Cancel: () 
      controller proposer 
      do 
        exercise baseAssetInSwapCid Cancel_Swap 
        return ()
    
    choice Trade_Reject: () 
      controller receiver 
      do 
        exercise baseAssetInSwapCid Reject_Swap 
        return ()

template AssetHoldingAccountCloseProposal with 
    account: AssetHoldingAccount 
  where 
    signatory account.assetType.issuer, account.owner 
    choice AssetHoldingAccountCloseProposal_Accept: () 
      with 
        assetCids: [ContractId Asset] 
      controller account.assetType.issuer 
      do 
        accountCid <- lookupByKey @AssetHoldingAccount (account.assetType, account.owner) 
        whenSome accountCid \cid -> do 
          forA_ assetCids \assetCid -> do 
            asset <- fetch assetCid 
            assertMsg "asset must have the same asset type as account" (asset.assetType == account.assetType) 
            assertMsg "asset must have the same owner as account" (asset.owner == account.owner) 
            archive assetCid 
          archive cid 
        return ()
    
    choice AssetHoldingAccountCloseProposal_Reject: () 
      controller account.assetType.issuer 
      do 
        return ()
