module Account where 

import DA.Set as Set
import DA.Foldable (forA_)
import qualified DA.List as L
import DA.Action (when)
import Asset

-- validate input and return difference between asset amounts and split amounts
validateMergeSplitInput: AssetHoldingAccount -> [ContractId Asset] -> [Decimal] -> Update Decimal 
validateMergeSplitInput account assetCids amounts = do 
  forA_ amounts \amount -> assertMsg "amount must > 0" (amount > 0.0)
  let splitAmount = sum amounts 
  totalAssetAmount <- sum <$> forA assetCids \assetCid -> do 
    asset <- fetch assetCid 
    assertMsg "must same assetType" (asset.assetType == account.assetType)
    assertMsg "must same owner" (asset.owner == account.owner)
    return asset.amount 
  assertMsg "asset amounts must be greater than split amounts" (totalAssetAmount >= splitAmount)

  return (totalAssetAmount - splitAmount)

-- AssetHoldingAccount needs invitation from issuer
-- owner can propose close account, issuer accepts with list of assetCids because needs to call from client side
-- Invite_New_Asset_Holder, Airdrop, Merge_Split
-- Create_Transfers && Deposit_Transfer_Into_Account

template AssetHoldingAccount with 
    assetType: AssetType 
    owner: Party 
    airdroppable: Bool 
    resharable: Bool 
  where 
    signatory assetType.issuer, owner 
    key (assetType, owner): (AssetType, Party) 
    maintainer key._1.issuer 

    nonconsuming choice Invite_New_Asset_Holder_1: () with -- cannot return ContractId AssetHoldingAccountProposal if use controller owner only
        recipient: Party 
      controller owner  
      do 
        assertMsg "account not resharable" (resharable) 
        create AssetHoldingAccountProposal with assetHoldingAccount = this, recipient 
        return () 

    nonconsuming choice Invite_New_Asset_Holder: ContractId AssetHoldingAccountProposal with 
        recipient: Party 
      controller (if resharable then owner else assetType.issuer)  
      do 
        create AssetHoldingAccountProposal with assetHoldingAccount = this , recipient 

    -- assetCids obtained in client side and passed to choice arguments
    nonconsuming choice Merge_Split: [ContractId Asset] with 
        assetCids: [ContractId Asset] 
        amounts: [Decimal] 
      controller owner 
      do 
        assertMsg "can only merge split fungible" (assetType.fungible)
        difference <- validateMergeSplitInput this assetCids amounts 
        forA_ assetCids archive 
        newAssetCids <- forA amounts \amount -> do 
          create Asset with assetType, owner, amount, observers = Set.empty 
        if (difference > 0.0) then do 
          otherAssetCid <- (create Asset with assetType, owner, amount = difference, observers = Set.empty)
          return (otherAssetCid :: newAssetCids)
        else return newAssetCids 
    
    nonconsuming choice Airdrop : ContractId Asset
      with
        amount : Decimal
      controller assetType.issuer 
      do
        assertMsg "account not airdroppable or issuer airdropping self" (airdroppable || assetType.issuer == owner)
        assertMsg "nonfungible must have amount equals 1.0" $ (assetType.fungible || amount==1.0)
        create Asset with assetType, owner, amount, observers = Set.empty
    
    nonconsuming choice Create_Transfers: [ContractId AssetTransfer]
      with 
        assetCids: [ContractId Asset] 
        transfers: [(Decimal, Party)]
      controller owner 
      do 
        let (amounts, newOwners) = unzip transfers 
        assertMsg "can only transfer 1 nonfungile asset at a time" (assetType.fungible || (length assetCids == 1 && length transfers == 1 && L.head amounts == 1.0))
        difference <- validateMergeSplitInput this assetCids amounts 
        forA_ assetCids archive
        newAssetCids <- forA transfers \(amount, newOwner) -> do 
          create AssetTransfer with 
            asset = Asset with 
              assetType 
              owner
              amount 
              observers = Set.empty 
            receiver = newOwner 
        when (difference > 0.0) do 
          create Asset with assetType, owner, amount = difference, observers = Set.empty
          return ()
        return newAssetCids 
    
    nonconsuming choice Deposit_Transfer_Into_Account: ContractId Asset 
      with 
        assetTransferCid: ContractId AssetTransfer 
      controller owner 
      do 
        assetTransfer <- fetch assetTransferCid 
        assertMsg "not same assetType" (assetTransfer.asset.assetType == assetType)
        assertMsg "asset holding owner and asset transfer receiver mismatch" (assetTransfer.receiver == owner)
        create Asset with assetType, owner, amount = assetTransfer.asset.amount, observers = Set.empty 
    
    nonconsuming choice Create_Trade: ContractId Trade 
      with 
        assetCids: [ContractId Asset] 
        offeredAmount: Decimal 
        requestedAsset: Asset 
      controller owner 
      do 
        assertMsg "can only trade 1 nonfungile asset at a time" (assetType.fungible || (length assetCids == 1 && offeredAmount == 1.0))
        difference <- validateMergeSplitInput this assetCids [offeredAmount] 
        forA_ assetCids archive 
        
        assetInSwapCid <- create AssetInSwap with 
          asset = Asset with assetType, owner, amount = offeredAmount, observers = Set.empty 
          newOwner = requestedAsset.owner 
        when (difference > 0.0) do 
          create Asset with assetType, owner, amount = difference, observers = Set.empty 
          return () 
        requestedAssetPreApprovalCid <- exercise self Preapprove_Transfer with 
          asset = requestedAsset 
        create Trade with 
          proposer = owner 
          receiver = requestedAsset.owner 
          baseAssetInSwapCid = assetInSwapCid 
          requestedAssetPreApprovalCid 

    nonconsuming choice Preapprove_Transfer: ContractId TransferPreApproval 
      with 
        asset: Asset 
      controller owner 
      do 
        create TransferPreApproval with 
          asset 
          newOwner = owner 


template AssetHoldingAccountProposal with 
    assetHoldingAccount: AssetHoldingAccount -- Record data type 
    recipient: Party -- we can remove this and use assetHoldingAccount.owner but it would make code hard to read
  where 
    signatory assetHoldingAccount.assetType.issuer 
    observer recipient 
    
    choice AssetHoldingAccountProposal_Accept: ContractId AssetHoldingAccount 
      controller recipient 
      do 
        create assetHoldingAccount with owner = recipient 
    
    choice AssetHoldingAccountProposal_Reject: () 
      controller recipient 
      do
        return ()
    
    choice AssetHoldingAccountProposal_Cancel: () 
      controller assetHoldingAccount.assetType.issuer 
      do 
        return () 

-- use AssetInSwap to lock the Asset 
-- cancel_swap first then cancel_trade => fail => AssetInSwap needs to have 2 signatories
template AssetInSwap with 
    asset: Asset 
    newOwner: Party 
  where 
    signatory (signatory asset) 
    observer newOwner 

-- preapproval created by receiver, asset is of sender
template TransferPreApproval with 
    asset: Asset 
    newOwner: Party 
  where 
    signatory asset.assetType.issuer, asset.owner 
    observer newOwner 

    choice TransferPreApproval_Reject: () 
      controller newOwner 
      do 
        return () 
    choice TransferPreApproval_Cancel: () 
      controller asset.owner 
      do 
        return ()
    choice TransferPreApproval_Accept: ContractId Asset 
      with 
        assetCid: ContractId Asset 
      controller asset.owner, newOwner 
      do 
        fetchedAsset <- fetch assetCid 
        assertMsg "preapproval asset and provided asset are not the same" (asset == fetchedAsset with observers = asset.observers)
        archive assetCid 
        create asset with owner = newOwner, observers = Set.empty 
    choice TransferPreApproval_AcceptSwap: ContractId Asset 
      with 
        assetInSwapCid: ContractId AssetInSwap 
      controller asset.owner, newOwner 
      do 
        assetInSwap <- fetch assetInSwapCid 
        assertMsg "preapproval asset and provided asset in swap are not the same" (asset == assetInSwap.asset with observers = asset.observers)
        archive assetInSwapCid
        create asset with owner = newOwner, observers = Set.empty 
        
template Trade with 
    proposer: Party 
    receiver: Party 
    baseAssetInSwapCid: ContractId AssetInSwap 
    requestedAssetPreApprovalCid: ContractId TransferPreApproval
  where 
    signatory proposer 
    observer receiver 

    choice Trade_Accept: (ContractId Asset, ContractId Asset) 
      with 
        requestedAssetCids: [ContractId Asset] 
      controller receiver  
      do 
        requestedAssetPreApproval <- fetch requestedAssetPreApprovalCid
        (receiverAccountCid, _) <- fetchByKey @AssetHoldingAccount (requestedAssetPreApproval.asset.assetType, receiver)
        requestedAssetMergeSplitCids <- exercise receiverAccountCid Merge_Split with 
          assetCids = requestedAssetCids 
          amounts = [requestedAssetPreApproval.asset.amount]
        baseAssetInSwap <- fetch baseAssetInSwapCid
        baseAssetPreApprovalCid <- exercise receiverAccountCid Preapprove_Transfer with 
          asset = baseAssetInSwap.asset 
        newReceiverAsset <- exercise baseAssetPreApprovalCid TransferPreApproval_AcceptSwap with assetInSwapCid = baseAssetInSwapCid
        newProposerAsset <- exercise requestedAssetPreApprovalCid TransferPreApproval_Accept with assetCid = L.last requestedAssetMergeSplitCids 
        return (newProposerAsset, newReceiverAsset)



