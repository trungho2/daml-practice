module Account.Test where 

import Daml.Script 
import DA.Set as Set 
import qualified DA.List as L

import Asset 
import Account 
import Asset.Test 

template Helper with 
    owner: Party 
  where 
    signatory owner 
    nonconsuming choice Fetch_Assets: [Asset] with 
        assetCids: [ContractId Asset] 
      controller owner 
      do 
        forA assetCids \assetCid -> fetch assetCid 
    nonconsuming choice Fetch_AssetTransfers: [AssetTransfer] with 
        assetTransferCids: [ContractId AssetTransfer] 
      controller owner 
      do 
        forA assetTransferCids \assetTransferCid -> fetch assetTransferCid 

test_Invite_Holder_resharable: Script () 
test_Invite_Holder_resharable = do 
  (parties@Parties{..}, assetData@AssetData{..}) <- setup 

  bobUsdInvitation <- submit alice $ exerciseCmd aliceUsdAccount Invite_New_Asset_Holder with recipient = bob 
  bobUsdAccount <- submit bob $ exerciseCmd bobUsdInvitation AssetHoldingAccountProposal_Accept 

  return () 

test_Invite_Holder_nonresharable = do 
  (parties@Parties{..}, assetData@AssetData{..}) <- setup 

  submitMustFail bob $ exerciseCmd bobEurAccount Invite_New_Asset_Holder with recipient = alice 

  return () 

test_nonairdoppable = do 
  (parties@Parties{..}, assetData@AssetData{..}) <- setup 

  submitMustFail artist $ exerciseCmd charlieNftAccount Airdrop with amount = 1.0

  return ()

test_nonfungible_airdoppable = do 
  (parties@Parties{..}, _) <- setup 

  let 
    nftAssetType = AssetType with 
      issuer = artist 
      symbol = "Picture1" 
      fungible = False 
      reference = Some "" 

  artistNftAccount <- submit artist $ createCmd AssetHoldingAccount with 
    assetType = nftAssetType 
    owner = artist 
    airdroppable = True   
    resharable = False  
  
  charlieNftInvitation <- submit artist $ exerciseCmd artistNftAccount Invite_New_Asset_Holder with recipient = charlie 
  charlieNftAccount <- submit charlie $ exerciseCmd charlieNftInvitation AssetHoldingAccountProposal_Accept 
  submitMustFail artist $ exerciseCmd charlieNftAccount Airdrop with amount = 2.0
  charlieNftAsset1 <- submit artist $ exerciseCmd charlieNftAccount Airdrop with amount = 1.0

  return () 

test_Merge_Split = do 
  (parties@Parties{..}, assetData@AssetData{..}) <- setup 

  assetCids <- submit alice $ exerciseCmd aliceUsdAccount Merge_Split with assetCids = aliceUsdAssets, amounts = [40.0, 80.0, 90.0] 
  helper <- submit alice $ createCmd Helper with owner = alice 
  assets <- submit alice $ exerciseCmd helper Fetch_Assets with assetCids 
  assertMsg "there must be 4 assets" (L.length assets == 4)
  let [asset1, asset2, asset3, asset4] = L.sortBy sortAssetByAmount assets 

  assert (asset1.amount == 10.0)
  assert (asset2.amount == 40.0)
  assert (asset3.amount == 80.0)
  assert (asset4.amount == 90.0)

  return ()

sortAssetByAmount a b 
  | a.amount > b.amount = GT 
  | a.amount < b.amount = LT 
  | a.amount == b.amount = EQ 

test_Merge_Split_amount_exceeds_balance = do 
  (parties@Parties{..}, assetData@AssetData{..}) <- setup 

  submitMustFail alice $ exerciseCmd aliceUsdAccount Merge_Split with assetCids = aliceUsdAssets, amounts = [110.0, 120.0] 

  return ()

test_Merge_Split_fungible_fail = do 
  (parties@Parties{..}, assetData@AssetData{..}) <- setup 

  submitMustFail charlie $ exerciseCmd charlieNftAccount Merge_Split with assetCids = [L.head charlieNftAssets], amounts = [1.0] 

  return ()

test_Merge_Split_negative_amount = do 
  (parties@Parties{..}, assetData@AssetData{..}) <- setup 

  submitMustFail alice $ exerciseCmd aliceUsdAccount Merge_Split with assetCids = aliceUsdAssets, amounts = [-30.0] 

  return ()

test_Merge_Split_assetType_mismatch = do 
  (parties@Parties{..}, assetData@AssetData{..}) <- setup 

  aliceEurInvitation <- submit eurBank $ exerciseCmd eurBankAccount Invite_New_Asset_Holder with recipient = alice 
  aliceEurAccount <- submit alice $ exerciseCmd aliceEurInvitation AssetHoldingAccountProposal_Accept 
  aliceEurAsset1 <- submit eurBank $ exerciseCmd aliceEurAccount Airdrop with amount = 10.0 

  submitMustFail alice $ exerciseCmd aliceUsdAccount Merge_Split with assetCids = aliceEurAsset1 :: aliceUsdAssets, amounts = [30.0] 

  return ()

test_Merge_Split_owner_mismatch = do 
  (parties@Parties{..}, assetData@AssetData{..}) <- setup 

  aliceEurInvitation <- submit eurBank $ exerciseCmd eurBankAccount Invite_New_Asset_Holder with recipient = alice 
  aliceEurAccount <- submit alice $ exerciseCmd aliceEurInvitation AssetHoldingAccountProposal_Accept 
  aliceEurAsset1 <- submit eurBank $ exerciseCmd aliceEurAccount Airdrop with amount = 10.0 
  nAliceEurAsset1 <- submit alice $ exerciseCmd aliceEurAsset1 Asset_Add_Observer with newObserver = bob  

  submitMustFail bob $ exerciseCmd bobEurAccount Merge_Split with assetCids = nAliceEurAsset1 :: bobEurAssets, amounts = [30.0] 

  return ()

test_Transfer = do 
  (parties@Parties{..}, assetData@AssetData{..}) <- setup 

  bobUsdInvitation <- submit usdBank $ exerciseCmd usdBankAccount Invite_New_Asset_Holder with recipient = bob 
  bobUsdAccount <- submit bob $ exerciseCmd bobUsdInvitation AssetHoldingAccountProposal_Accept 
  charlieUsdInvitation <- submit usdBank $ exerciseCmd usdBankAccount Invite_New_Asset_Holder with recipient = charlie
  charlieUsdAccount <- submit charlie $ exerciseCmd charlieUsdInvitation AssetHoldingAccountProposal_Accept 

  assetTransferCids <- submit alice $ exerciseCmd aliceUsdAccount Create_Transfers with 
    assetCids = take 2 aliceUsdAssets 
    transfers = [(25.0, bob), (35.0, bob), (40.0, charlie)] 
  
  bobHelper <- submit bob $ createCmd Helper with owner = bob 
  -- assetTransferCids might not be in the same order as in transfers
  assetTransfers <- submit bob $ exerciseCmd bobHelper Fetch_AssetTransfers with assetTransferCids = (take 2 assetTransferCids)  
  
  let assetTransfer1 = L.head assetTransfers 
  debug(assetTransfer1)
  assert (assetTransfer1.receiver == bob)
  assert (assetTransfer1.asset.amount == 25.0)

  let assetTransferCid2 = (L.!!) assetTransferCids 1
  bobUsdAssetCid2 <- submit bob $ exerciseCmd bobUsdAccount Deposit_Transfer_Into_Account with assetTransferCid = assetTransferCid2 
  bobUsdAssets <- submit bob $ exerciseCmd bobHelper Fetch_Assets with assetCids = [bobUsdAssetCid2] 
  let bobUsdAsset2 = L.head bobUsdAssets 
  assert (bobUsdAsset2.amount == 35.0) 

  charlieHelper <- submit charlie $ createCmd Helper with owner = charlie 
  charlieUsdAssetCid <- submit charlie $ exerciseCmd charlieUsdAccount Deposit_Transfer_Into_Account with assetTransferCid = L.last assetTransferCids
  charlieUsdAssets <- submit charlie $ exerciseCmd charlieHelper Fetch_Assets with assetCids = [charlieUsdAssetCid] 
  let charlieUsdAsset = L.head charlieUsdAssets 
  assert (charlieUsdAsset.amount == 40.0)
  
  return ()

test_Transfer_nonfungible_fail = do 
  (parties@Parties{..}, assetData@AssetData{..}) <- setup 

  let 
    nftAssetType = AssetType with 
      issuer = artist 
      symbol = "Picture" 
      fungible = False 
      reference = Some "" 

  nftAsset3 <- submit artist $ createCmd Asset with assetType = nftAssetType, owner = artist, amount = 1.0, observers = Set.empty 
  nftAsset4 <- submit artist $ createCmd Asset with assetType = nftAssetType, owner = artist, amount = 1.0, observers = Set.empty 
  submitMustFail artist $ exerciseCmd artistNftAccount Create_Transfers with 
    assetCids = [nftAsset3, nftAsset4] 
    transfers = [(1.0, charlie), (1.0, charlie)] 
  
  return ()

test_Transfer_exceeds_balance = do 
  (parties@Parties{..}, assetData@AssetData{..}) <- setup 

  bobUsdInvitation <- submit usdBank $ exerciseCmd usdBankAccount Invite_New_Asset_Holder with recipient = bob 
  bobUsdAccount <- submit bob $ exerciseCmd bobUsdInvitation AssetHoldingAccountProposal_Accept 
  
  submitMustFail alice $ exerciseCmd aliceUsdAccount Create_Transfers with 
    assetCids = take 2 aliceUsdAssets 
    transfers = [(120.1, bob)] 

  return ()

test_Trade_fungible_for_fungible = do 
  (parties@Parties{..}, assetData@AssetData{..}) <- setup 

  let 
    eurAssetType = AssetType with 
      issuer = eurBank 
      symbol = "EUR" 
      fungible = True 
      reference = Some "" 
  
  aliceEurInvitation <- submit eurBank $ exerciseCmd eurBankAccount Invite_New_Asset_Holder with recipient = alice 
  aliceEurAccount <- submit alice $ exerciseCmd aliceEurInvitation AssetHoldingAccountProposal_Accept 
  bobUsdInvitation <- submit usdBank $ exerciseCmd usdBankAccount Invite_New_Asset_Holder with recipient = bob 
  bobUsdAccount <- submit bob $ exerciseCmd bobUsdInvitation AssetHoldingAccountProposal_Accept 

  tradeCid <- submit alice $ exerciseCmd aliceUsdAccount Create_Trade with 
    assetCids = aliceUsdAssets 
    offeredAmount = 180.0 
    requestedAsset = Asset with assetType = eurAssetType, owner = bob, amount = 180.0, observers = Set.empty 
  
  (aliceEurAssetCid, bobUsdAssetCid) <- submit bob $ exerciseCmd tradeCid Trade_Accept with requestedAssetCids = bobEurAssets 

  aliceHelper <- submit alice $ createCmd Helper with owner = alice 
  bobHelper <- submit bob $ createCmd Helper with owner = bob 

  aliceEurAssets <- submit alice $ exerciseCmd aliceHelper Fetch_Assets with assetCids = [aliceEurAssetCid] 
  bobUsdAssets <- submit bob $ exerciseCmd bobHelper Fetch_Assets with assetCids = [bobUsdAssetCid] 

  let 
    aliceEurAsset = L.head aliceEurAssets 
    bobUsdAsset = L.head bobUsdAssets 
  
  assert (aliceEurAsset.amount == 180.0)
  assert (aliceEurAsset.assetType.symbol == "EUR")
  assert (bobUsdAsset.amount == 180.0)
  assert (bobUsdAsset.assetType.symbol == "USD")

  return ()

test_Trade_fungible_for_nonfungible = do 
  (parties@Parties{..}, assetData@AssetData{..}) <- setup 

  let 
    nftAssetType = AssetType with 
      issuer = artist 
      symbol = "Picture" 
      fungible = False 
      reference = Some "" 

  aliceNftInvitation <- submit artist $ exerciseCmd artistNftAccount Invite_New_Asset_Holder with recipient = alice 
  aliceNftAccount <- submit alice $ exerciseCmd aliceNftInvitation AssetHoldingAccountProposal_Accept 
  charlieUsdInvitation <- submit usdBank $ exerciseCmd usdBankAccount Invite_New_Asset_Holder with recipient = charlie 
  charlieUsdAccount <- submit charlie $ exerciseCmd charlieUsdInvitation AssetHoldingAccountProposal_Accept 

  tradeCid <- submit alice $ exerciseCmd aliceUsdAccount Create_Trade with 
    assetCids = aliceUsdAssets 
    offeredAmount = 180.0 
    requestedAsset = Asset with assetType = nftAssetType, owner = charlie, amount = 1.0, observers = Set.empty 
  
  (aliceNftAssetCid, charlieUsdAssetCid) <- submit charlie $ exerciseCmd tradeCid Trade_Accept with requestedAssetCids = [L.head charlieNftAssets] 

  aliceHelper <- submit alice $ createCmd Helper with owner = alice 
  charlieHelper <- submit charlie $ createCmd Helper with owner = charlie 

  aliceNftAssets <- submit alice $ exerciseCmd aliceHelper Fetch_Assets with assetCids = [aliceNftAssetCid] 
  charlieUsdAssets <- submit charlie $ exerciseCmd charlieHelper Fetch_Assets with assetCids = [charlieUsdAssetCid] 

  let 
    aliceNftAsset = L.head aliceNftAssets 
    charlieUsdAsset = L.head charlieUsdAssets 
  
  assert (aliceNftAsset.amount == 1.0)
  assert (aliceNftAsset.assetType.symbol == "Picture")
  assert (charlieUsdAsset.amount == 180.0)
  assert (charlieUsdAsset.assetType.symbol == "USD")

  return ()


test_Trade_nonfungible_for_fungible = do 
  (parties@Parties{..}, assetData@AssetData{..}) <- setup 

  let 
    eurAssetType = AssetType with 
      issuer = eurBank 
      symbol = "EUR" 
      fungible = True 
      reference = Some "" 
  
  charlieEurInvitation <- submit eurBank $ exerciseCmd eurBankAccount Invite_New_Asset_Holder with recipient = charlie 
  charlieEurAccount <- submit charlie $ exerciseCmd charlieEurInvitation AssetHoldingAccountProposal_Accept 
  bobNftInvitation <- submit artist $ exerciseCmd artistNftAccount Invite_New_Asset_Holder with recipient = bob 
  bobNftAccount <- submit bob $ exerciseCmd bobNftInvitation AssetHoldingAccountProposal_Accept 

  tradeCid <- submit charlie $ exerciseCmd charlieNftAccount Create_Trade with 
    assetCids = [L.last charlieNftAssets] 
    offeredAmount = 1.0 
    requestedAsset = Asset with assetType = eurAssetType, owner = bob, amount = 150.0, observers = Set.empty 
  
  (charlieEurAssetCid, bobNftAssetCid) <- submit bob $ exerciseCmd tradeCid Trade_Accept with requestedAssetCids = bobEurAssets 

  charlieHelper <- submit charlie $ createCmd Helper with owner = charlie 
  bobHelper <- submit bob $ createCmd Helper with owner = bob 

  charlieEurAssets <- submit charlie $ exerciseCmd charlieHelper Fetch_Assets with assetCids = [charlieEurAssetCid] 
  bobNftAssets <- submit bob $ exerciseCmd bobHelper Fetch_Assets with assetCids = [bobNftAssetCid] 

  let 
    charlieEurAsset = L.head charlieEurAssets 
    bobNftAsset = L.head bobNftAssets 
  
  assert (charlieEurAsset.amount == 150.0)
  assert (charlieEurAsset.assetType.symbol == "EUR")
  assert (bobNftAsset.amount == 1.0)
  assert (bobNftAsset.assetType.symbol == "Picture")

  return ()
